"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9077],{27113:(e,r,t)=>{t.d(r,{A:()=>d});var n=t(11463),u=t(51440),a=t(83696);let i=n.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;if("rejected"===e.status)throw e.reason;throw e.status="pending",e.then(r=>{e.status="fulfilled",e.value=r},r=>{e.status="rejected",e.reason=r}),e}),s={dedupe:!0};a.qv.defineProperty(a.BE,"defaultValue",{value:a.sb});let l=(0,a.qm)((e,r,t)=>{let{cache:l,compare:o,suspense:c,fallbackData:d,revalidateOnMount:g,revalidateIfStale:f,refreshInterval:b,refreshWhenHidden:E,refreshWhenOffline:R,keepPreviousData:h}=t,[V,w,T,C]=a.bZ.get(l),[k,m]=(0,a.lK)(e),p=(0,n.useRef)(!1),L=(0,n.useRef)(!1),O=(0,n.useRef)(k),_=(0,n.useRef)(r),v=(0,n.useRef)(t),y=()=>v.current,S=()=>y().isVisible()&&y().isOnline(),[M,N,A,H]=(0,a.r9)(l,k),Z=(0,n.useRef)({}).current,D=(0,a.b0)(d)?t.fallback[k]:d;D&&(0,a.$X)(D)&&(D=i(D));let F=(e,r)=>{for(let t in Z)if("data"===t){if(!o(e[t],r[t])&&(!(0,a.b0)(e[t])||!o(B,r[t])))return!1}else if(r[t]!==e[t])return!1;return!0},P=(0,n.useMemo)(()=>{let e=!!k&&!!r&&((0,a.b0)(g)?!y().isPaused()&&!c&&(!!(0,a.b0)(f)||f):g),t=r=>{let t=(0,a.rL)(r);return(delete t._k,e)?{isValidating:!0,isLoading:!0,...t}:t},n=M(),u=H(),i=t(n),s=n===u?i:t(u),l=i;return[()=>{let e=t(M());return F(e,l)?(l.data=e.data,l.isLoading=e.isLoading,l.isValidating=e.isValidating,l.error=e.error,l):(l=e,e)},()=>s]},[l,k]),I=(0,u.useSyncExternalStore)((0,n.useCallback)(e=>A(k,(r,t)=>{F(t,r)||e()}),[l,k]),P[0],P[1]),U=!p.current,X=V[k]&&V[k].length>0,q=I.data,j=(0,a.b0)(q)?D:q,K=I.error,x=(0,n.useRef)(j),B=h?(0,a.b0)(q)?x.current:q:j,$=(!X||!!(0,a.b0)(K))&&(U&&!(0,a.b0)(g)?g:!y().isPaused()&&(c?!(0,a.b0)(j)&&f:(0,a.b0)(j)||f)),z=!!(k&&r&&U&&$),G=(0,a.b0)(I.isValidating)?z:I.isValidating,J=(0,a.b0)(I.isLoading)?z:I.isLoading,Q=(0,n.useCallback)(async e=>{let r,n,u=_.current;if(!k||!u||L.current||y().isPaused())return!1;let i=!0,s=e||{},l=!T[k]||!s.dedupe,c=()=>a.dO?!L.current&&k===O.current&&p.current:k===O.current,d={isValidating:!1,isLoading:!1},g=()=>{N(d)},f=()=>{let e=T[k];e&&e[1]===n&&delete T[k]},b={isValidating:!0};(0,a.b0)(M().data)&&(b.isLoading=!0);try{if(l&&(N(b),t.loadingTimeout&&(0,a.b0)(M().data)&&setTimeout(()=>{i&&c()&&y().onLoadingSlow(k,t)},t.loadingTimeout),T[k]=[u(m),(0,a.lg)()]),[r,n]=T[k],r=await r,l&&setTimeout(f,t.dedupingInterval),!T[k]||T[k][1]!==n)return l&&c()&&y().onDiscarded(k),!1;d.error=a.ZH;let e=w[k];if(!(0,a.b0)(e)&&(n<=e[0]||n<=e[1]||0===e[1]))return g(),l&&c()&&y().onDiscarded(k),!1;let s=M().data;d.data=o(s,r)?s:r,l&&c()&&y().onSuccess(r,k,t)}catch(t){f();let e=y(),{shouldRetryOnError:r}=e;!e.isPaused()&&(d.error=t,l&&c()&&(e.onError(t,k,e),(!0===r||(0,a.Tn)(r)&&r(t))&&(!y().revalidateOnFocus||!y().revalidateOnReconnect||S())&&e.onErrorRetry(t,k,e,e=>{let r=V[k];r&&r[0]&&r[0](a.bu.ERROR_REVALIDATE_EVENT,e)},{retryCount:(s.retryCount||0)+1,dedupe:!0})))}return i=!1,g(),!0},[k,l]),W=(0,n.useCallback)((...e)=>(0,a.mF)(l,O.current,...e),[]);if((0,a.Es)(()=>{_.current=r,v.current=t,(0,a.b0)(q)||(x.current=q)}),(0,a.Es)(()=>{if(!k)return;let e=Q.bind(a.ZH,s),r=0,t=(0,a.aw)(k,V,(t,n={})=>{if(t==a.bu.FOCUS_EVENT){let t=Date.now();y().revalidateOnFocus&&t>r&&S()&&(r=t+y().focusThrottleInterval,e())}else if(t==a.bu.RECONNECT_EVENT)y().revalidateOnReconnect&&S()&&e();else if(t==a.bu.MUTATE_EVENT)return Q();else if(t==a.bu.ERROR_REVALIDATE_EVENT)return Q(n)});return L.current=!1,O.current=k,p.current=!0,N({_k:m}),$&&((0,a.b0)(j)||a.X3?e():(0,a.mf)(e)),()=>{L.current=!0,t()}},[k]),(0,a.Es)(()=>{let e;function r(){let r=(0,a.Tn)(b)?b(M().data):b;r&&-1!==e&&(e=setTimeout(t,r))}function t(){!M().error&&(E||y().isVisible())&&(R||y().isOnline())?Q(s).then(r):r()}return r(),()=>{e&&(clearTimeout(e),e=-1)}},[b,E,R,k]),(0,n.useDebugValue)(B),c&&(0,a.b0)(j)&&k){if(!a.dO&&a.X3)throw Error("Fallback data is required when using suspense in SSR.");_.current=r,v.current=t,L.current=!1;let e=C[k];if((0,a.b0)(e)||i(W(e)),(0,a.b0)(K)){let e=Q(s);(0,a.b0)(B)||(e.status="fulfilled",e.value=!0),i(e)}else throw K}return{mutate:W,get data(){return Z.data=!0,B},get error(){return Z.error=!0,K},get isValidating(){return Z.isValidating=!0,G},get isLoading(){return Z.isLoading=!0,J}}}),o=a.dO?e=>{e()}:n.startTransition,c=e=>{let[,r]=(0,n.useState)({}),t=(0,n.useRef)(!1),u=(0,n.useRef)(e),i=(0,n.useRef)({data:!1,error:!1,isValidating:!1}),s=(0,n.useCallback)(e=>{let n=!1,a=u.current;for(let r in e)a[r]!==e[r]&&(a[r]=e[r],i.current[r]&&(n=!0));n&&!t.current&&r({})},[]);return(0,a.Es)(()=>(t.current=!1,()=>{t.current=!0})),[u,i.current,s]},d=(0,a.Ht)(l,()=>(e,r,t={})=>{let{mutate:u}=(0,a.iX)(),i=(0,n.useRef)(e),s=(0,n.useRef)(r),l=(0,n.useRef)(t),d=(0,n.useRef)(0),[g,f,b]=c({data:a.ZH,error:a.ZH,isMutating:!1}),E=g.current,R=(0,n.useCallback)(async(e,r)=>{let[t,n]=(0,a.lK)(i.current);if(!s.current)throw Error("Can’t trigger the mutation: missing fetcher.");if(!t)throw Error("Can’t trigger the mutation: missing key.");let c=(0,a.rL)((0,a.rL)({populateCache:!1,throwOnError:!0},l.current),r),g=(0,a.lg)();d.current=g,b({isMutating:!0});try{let r=await u(t,s.current(n,{arg:e}),(0,a.rL)(c,{throwOnError:!0}));return d.current<=g&&(o(()=>b({data:r,isMutating:!1,error:void 0})),null==c.onSuccess||c.onSuccess.call(c,r,t,c)),r}catch(e){if(d.current<=g&&(o(()=>b({error:e,isMutating:!1})),null==c.onError||c.onError.call(c,e,t,c),c.throwOnError))throw e}},[]),h=(0,n.useCallback)(()=>{d.current=(0,a.lg)(),b({data:a.ZH,error:a.ZH,isMutating:!1})},[]);return(0,a.Es)(()=>{i.current=e,s.current=r,l.current=t}),{trigger:R,reset:h,get data(){return f.data=!0,E.data},get error(){return f.error=!0,E.error},get isMutating(){return f.isMutating=!0,E.isMutating}}})},32133:(e,r,t)=>{t.d(r,{Ak:()=>n});let n=(e=21)=>crypto.getRandomValues(new Uint8Array(e)).reduce((e,r)=>((r&=63)<36?e+=r.toString(36):r<62?e+=(r-26).toString(36).toUpperCase():r>62?e+="-":e+="_",e),"")}}]);