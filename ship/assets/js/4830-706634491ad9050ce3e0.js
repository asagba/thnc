(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4830],{4086:(e,n,t)=>{"use strict";t.r(n),t.d(n,{Link:()=>m});var i=t(71471),o=t(31775),r=t(50435),a=t(3213),l=t(62062),u=t(69404),s=t(67941),c=t(18090),p=t.n(c);function m(e){let{className:n,children:t,newTab:c,unstyled:m,scramble:v=!0,suffix:f,onClick:d,track:x,prefix:g,href:y,...h}=e,{session:S}=(0,s.w)(),{focusProps:C,isFocusVisible:z}=(0,o.og)({isTextInput:!0});return(0,i.jsxs)(a.Link,{className:(0,r.$)(p().link,"inline-flex items-center whitespace-nowrap font-mono text-sm uppercase",{"keyboard-focus":z,"text-gray-1000":!m,"phover:opacity-70 transition-opacity duration-200":!v},n),href:y,onBlur:e=>{var n;null==(n=C.onBlur)||n.call(C,e)},onClick:e=>{null==d||d(e),x&&(0,u.m9)({clickName:x.name,clickValue:x.value,sessionEmail:(null==S?void 0:S.loggedIn)?S.data.email:void 0})},onFocus:e=>{var n;null==(n=C.onFocus)||n.call(C,e)},...c?{target:"_blank",rel:"noopener noreferrer"}:{},...h,children:[g?(0,i.jsx)("span",{className:"mr-2",children:g}):null,v&&"string"==typeof t?(0,i.jsx)(l.i,{text:t}):t,f?(0,i.jsx)("span",{className:"ml-2",children:f}):null]})}},4748:(e,n,t)=>{"use strict";t.d(n,{Mb:()=>l,NG:()=>a,Ny:()=>r,eQ:()=>c,pw:()=>s});var i=t(11463),o=t(12072);let r=()=>window.matchMedia("(max-width: 961px)").matches,a=()=>window.matchMedia("(prefers-reduced-motion: reduce)").matches,l=()=>!r()&&!a(),u=()=>({top:0,left:0,width:0,height:0}),s=(0,o.Ay)((e,n)=>({shouldUseWebGL:void 0,rendererStarted:!1,heroLetterP:u(),heroLetterH:u(),heroLetterI:u(),heroLetterS:u(),getTicketsCta:{...u(),hover:!1},getTicektsSection:{...u(),hover:!1},footerLogo:u(),updateItem:(e,t)=>{Object.assign(n()[e],t)}})),c=e=>{let{elementRef:n,onUpdate:t,scroll:o=!0}=e,r=(0,i.useRef)(u()),a=(0,i.useRef)(t);a.current=t;let l=(0,i.useCallback)(()=>{var e;let t=n.current;if(!t)return;let i=t.getClientRects()[0];if(!i)return;let{top:o,left:l,width:u,height:s}=i;r.current={top:o,left:l,width:u,height:s},null==(e=a.current)||e.call(a,{top:o,left:l,width:u,height:s})},[n]);return(0,i.useEffect)(()=>{let e=n.current,t=new ResizeObserver(l);return e&&t.observe(e),window.addEventListener("resize",l),window.addEventListener("load",l),o&&window.addEventListener("scroll",l),l(),()=>{window.removeEventListener("resize",l),window.removeEventListener("load",l),window.removeEventListener("scroll",l)}},[n,o,l]),{ref:r,updateSize:l}}},16449:(e,n,t)=>{"use strict";t.d(n,{P:()=>i});let i=function(e){let{appendFragment:n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e({vert:"\n      precision highp float;\n      attribute vec2 position, uv;\n      varying vec2 vUv;\n      uniform vec2 screenSize;\n      uniform vec2 imagePosition;\n      uniform vec2 size;\n      uniform bool fixY;\n\n      void main () {\n        vUv = uv;\n        if(fixY) {\n          vUv.y = 1. - vUv.y;\n        }\n        vec2 scaleFactor = size / screenSize;\n        vec2 p = position * scaleFactor;\n\n\n        vec2 topLeft = (screenSize - size - imagePosition * 2.) / vec2(screenSize.x, -screenSize.y);\n\n        p -= topLeft;\n\n        gl_Position = vec4(p, 0, 1);\n      }",frag:"\n      precision highp float;\n      uniform sampler2D texture;\n      varying vec2 vUv;\n      void main () {\n        vec2 uv = vUv;\n        gl_FragColor = texture2D(texture, vUv);\n        ".concat(n||"","\n      }"),attributes:{position:[-1,-1,1,-1,-1,1,1,1],uv:[0,1,1,1,0,0,1,0]},uniforms:{fixY:(e,n)=>{var t;return null!=(t=n.fixY)&&t},texture:e.prop("texture"),screenSize:e=>[e.viewportWidth,e.viewportHeight],imagePosition:(e,n)=>{let{pixelRatio:t}=e,{imagePosition:i,fixPixelRatio:o}=n;return[i[0]*(o?t:1),i[1]*(o?t:1)]},size:(e,n)=>{let{pixelRatio:t}=e,{width:i,height:o,fixPixelRatio:r}=n,a=r?t:1;return o?[i*a,o*a]:[i*a,n.texture.height/n.texture.width*i*a]}},elements:[[0,1,2],[2,1,3]],count:6})}},18090:e=>{e.exports={link:"link_link__akFwq"}},36519:(e,n,t)=>{"use strict";t.d(n,{n:()=>d});var i=t(71471),o=t(11463),r=t(91635),a=t.n(r),l=t(1955),u=t.n(l),s=t(13035),c=t.n(s),p=t(49724);let m=(e,n,t)=>e*(1-t)+n*t,v=e=>{let{lerp:n=1}=e,t=(0,o.useRef)({x:0,y:0}),i=(0,o.useRef)({x:0,y:0}),r=(0,o.useRef)(!0);return(0,o.useEffect)(()=>{let e=e=>{r.current&&(i.current.x=e.clientX,i.current.y=e.clientY,r.current=!1),t.current={x:e.clientX,y:e.clientY}},o=0,a=e=>{let r=Math.min(1,n*(e-o)/100);i.current.x=m(i.current.x,t.current.x,r),i.current.y=m(i.current.y,t.current.y,r),o=e,requestAnimationFrame(a)};return requestAnimationFrame(a),window.addEventListener("mousemove",e),()=>{window.removeEventListener("mousemove",e)}},[i,t,n]),i};var f=t(4748);function d(e){let{reglOptions:n,getAssetsConfig:t,onFrame:r,onSetup:l,onDestroy:s,onStart:d,className:x,...g}=e,[y,h]=(0,o.useState)(window.devicePixelRatio),[S,C]=(0,o.useState)(null),z=(0,o.useRef)(S),{ref:P}=(0,f.eQ)({elementRef:z}),w=v({lerp:.5}),b=(0,o.useRef)(!0),D=(0,o.useCallback)(e=>{"getClientRects"in e&&(e.width=e.getClientRects()[0].width*y,e.height=e.getClientRects()[0].height*y)},[y]),M=(0,o.useRef)(0);return(0,o.useEffect)(()=>{try{if(!S)return;let e=!0;M.current=0;let i=a()({attributes:{...null==n?void 0:n.attributes},...n,canvas:S}),o=l?l(i):{},p=null,v={},f=.5,x=e=>{b.current&&(b.current=!1,d&&d());let{viewportWidth:n,viewportHeight:t,time:a}=e,l=window.devicePixelRatio||1,u=a-M.current;M.current=a;let s=c()(100*u/3,0,1);s=Math.round(10*s)/10,s=f=m(f,s,.01),y!==l&&h(l);let p=S.getClientRects()[0],x=[(w.current.x-p.left)/n*y,1-(w.current.y-p.top)/t*y];r&&r(i,e,{pixelRatio:y,canvasRect:p,mousePosition:x,trackedCanvas:P.current,delta:u,normalizedDelta:s,...o},v)};return t?u()({manifest:t(i),onDone:n=>{e&&(v=n,D(i._gl.canvas),p=i.frame(x))}}):(D(i._gl.canvas),p=i.frame(x)),()=>{p&&p.cancel(),e=!1,i.destroy(),s&&s()}}catch(e){console.error(e)}},[S,w,P,D,y,h,n,l,t,r,s,b,d]),(0,o.useEffect)(()=>{if(S)return e(),window.addEventListener("resize",e),()=>{window.removeEventListener("resize",e)};function e(){S&&D(S)}},[S,D]),(0,i.jsx)("canvas",{className:(0,p.cn)("absolute inset-0 h-full w-full",x),...g,ref:e=>{z.current=e,C(e)}})}},40375:(e,n,t)=>{"use strict";t.d(n,{b:()=>i});let i="\nfloat valueRemap(float value, float inputMin, float inputMax, float outputMin, float outputMax) {\n  float inputRange = inputMax - inputMin;\n  float outputRange = outputMax - outputMin;\n  float valueScaled = (value - inputMin) / inputRange;\n  return outputMin + (valueScaled * outputRange);\n}\n"},50559:(e,n,t)=>{"use strict";t.d(n,{F:()=>a});var i=t(71471),o=t(49724);function r(e){let{type:n="cross",...t}=e;return"dot"===n?(0,i.jsx)("div",{...t,className:(0,o.cn)("border-gray-1000 bg-gray-1000 h-[5px] w-[5px]",t.className)}):(0,i.jsx)("div",{...t,className:(0,o.cn)("border-gray-1000 h-3.5 w-3.5 border-l border-t",t.className)})}function a(e){let{type:n="cross"}=e;return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r,{className:(0,o.cn)("absolute z-10",{"left-[-1px] top-[-1px] rotate-0":"cross"===n,"left-[-3px] top-[-3px]":"dot"===n}),type:n}),(0,i.jsx)(r,{className:(0,o.cn)("absolute z-10",{"right-[-1px] top-[-1px] rotate-90":"cross"===n,"right-[-3px] top-[-3px]":"dot"===n}),type:n}),(0,i.jsx)(r,{className:(0,o.cn)("absolute z-10",{"bottom-[-1px] left-[-1px] -rotate-90":"cross"===n,"bottom-[-3px] left-[-3px]":"dot"===n}),type:n}),(0,i.jsx)(r,{className:(0,o.cn)("absolute z-10",{"bottom-[-1px] right-[-1px] rotate-180":"cross"===n,"bottom-[-3px] right-[-3px]":"dot"===n}),type:n})]})}},60242:(e,n,t)=>{"use strict";t.d(n,{a:()=>r});var i=t(96995),o=t(40375);let r=e=>e({vert:"\n      precision highp float;\n      attribute vec2 position;\n      varying vec2 uv;\n      void main() {\n        uv = 0.5 * (position + 1.0);\n        gl_Position = vec4(position, 0, 1);\n      }",frag:"\n      precision highp float;\n      uniform sampler2D texture;\n      uniform sampler2D shapeTexture;\n      uniform float delta;\n      uniform float normalizedDelta;\n      uniform float aspect;\n      uniform vec2 mouse;\n      uniform vec2 dSize;\n      uniform vec2 shapeTextureDSize;\n      uniform float uTime;\n      uniform float pixelRatio;\n      uniform float fluidSpreadVelocity;\n      uniform float mouseSize;\n      uniform float mouseSizeFactor;\n\n      ".concat(i.B,"\n      ").concat(o.b,"\n\n      varying vec2 uv;\n\n\n      vec4 prevFrame[9];\n      vec4 prevCenter;\n      float pixelConductivity = 0.;\n      float expansionScale = 0.7;\n\n      vec4 getSample(int i, int j) {\n        vec2 sampleUv = uv + normalize(vec2(float(i), float(j))) * vec2(1. / aspect, 1.) * (expansionScale * mouseSizeFactor * fluidSpreadVelocity) * 0.005;\n        sampleUv.y = 1. - sampleUv.y;\n        return texture2D(texture, sampleUv);\n      }\n\n      vec4 getShapeSample(int i, int j) {\n        vec2 sampleUv = uv + normalize(vec2(float(i), float(j))) * vec2(1. / aspect, 1.) * (expansionScale * mouseSizeFactor * fluidSpreadVelocity) * 0.01;\n        return texture2D(shapeTexture, sampleUv);\n      }\n\n      void getPixelConductivity() {\n\n        pixelConductivity = max(getShapeSample(-1, -1).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(0, -1).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(1, -1).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(-1, 0).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(0, 0).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(1, 0).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(-1, 1).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(0, 1).b, pixelConductivity);\n        pixelConductivity = max(getShapeSample(1, 1).b, pixelConductivity);\n\n      }\n\n      void getPrevFrame() {\n        prevCenter = texture2D(texture, vec2(uv.x, 1.-uv.y));\n\n        prevFrame[0] = getSample(-1, -1);\n        prevFrame[1] = getSample(0, -1);\n        prevFrame[2] = getSample(1, -1);\n        prevFrame[3] = getSample(-1, 0);\n        prevFrame[4] = prevCenter;\n        prevFrame[5] = getSample(1, 0);\n        prevFrame[6] = getSample(-1, 1);\n        prevFrame[7] = getSample(0, 1);\n        prevFrame[8] = getSample(1, 1);\n      }\n\n      vec2 clamp2(vec2 v, float min, float max) {\n        return vec2(clamp(v.x, min, max), clamp(v.y, min, max));\n      }\n\n      #define IS_DEBUG 0\n\n      float fadeColor(float x) {\n        float fadeFactor = 1. - pixelConductivity;\n        float result = x - fadeFactor;\n\n        float deltaScaler = valueRemap(normalizedDelta, 0.0, 1.0, 1.0, 0.8);\n\n        if(pixelConductivity < 0.9) {\n          result = result * deltaScaler;\n        }\n\n        result = clamp(result, 0., 1.);\n        return result;\n      }\n\n      float fadePrevCenter(float x) {\n\n        float scaleFactor = mix(0.9, 0.99, x);\n\n        float deltaScaler = valueRemap(normalizedDelta, 0.0, 1.0, 1.0, 0.9);\n\n        float result = x * scaleFactor * deltaScaler;\n        result = clamp(result, 0., 1.);\n        if(result < 0.05) {\n          result = 0.;\n        }\n        return result;\n      }\n\n      void main() {\n        vec4 debug = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n        vec2 toAspect = vec2(1., 1. / aspect);\n        getPrevFrame();\n        getPixelConductivity();\n        vec2 aspectUv = uv * toAspect;\n        vec2 aspectMouse = mouse * toAspect;\n\n        float noiseSample = cnoise(aspectUv * 50. + vec2(uTime) * 0.01);\n        float noiseFactor = 1. - noiseSample * 0.4;\n\n        vec2 prevMouseDir = prevCenter.xy;\n        prevMouseDir = (prevMouseDir * 2.0) - 1.0;\n        vec2 mouseDir = normalize(aspectMouse - aspectUv);\n\n\n        float mouseSdf =  1. - length(aspectUv - aspectMouse) * mouseSize * noiseFactor;\n        mouseSdf *= mouseSizeFactor;\n        mouseSdf = clamp(mouseSdf, 0., 1.);\n        mouseSdf = pow(mouseSdf, 1.);\n\n        float prevFrameZ = prevCenter.z;\n\n        float maxDirecitonMix = mix(0.05, 0.3, normalizedDelta);\n        float minDirecitonMix = mix(0.001, 0.1, normalizedDelta);\n\n        // the more active the effect on prev frame, the less we mix the new direction\n        float mouseDirMix = mix(maxDirecitonMix, minDirecitonMix, prevFrameZ);\n\n        // calculate similarity betwween the current and previous direction\n        float similarity = dot(mouseDir, prevMouseDir);\n        // less similar, the more we mix the new direction\n        mouseDirMix = mix(maxDirecitonMix, mouseDirMix, similarity);\n        mouseDirMix = clamp(mouseDirMix, 0., 1.);\n\n        mouseDir = mix(\n          prevMouseDir,\n          mouseDir,\n          mouseDirMix\n        );\n\n        // remap vector to 0 - 1\n        mouseDir = (mouseDir + 1.0) * 0.5;\n        result.xy = mouseDir;\n\n        float color = 0.;\n        color += mouseSdf * 0.8;\n\n        float prevColorFactor = 1.0;\n\n        float maxPrevColor = fadeColor(prevFrame[0].z);\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[1].z));\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[2].z));\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[3].z));\n        maxPrevColor = max(maxPrevColor, fadePrevCenter(prevFrame[4].z)); //center\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[5].z));\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[6].z));\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[7].z));\n        maxPrevColor = max(maxPrevColor, fadeColor(prevFrame[8].z));\n\n        result.z = color;\n        result.z += maxPrevColor;\n        result.z = clamp(result.z, 0., 1.);\n\n        #if IS_DEBUG\n          result = debug;\n        #endif\n\n\n        gl_FragColor = result;\n\n        // gl_FragColor.xy = vec2(0.);\n        // gl_FragColor.z = 0.;\n\n\n      }\n    "),attributes:{position:[-4,-4,4,-4,0,4]},depth:{enable:!1},count:3,uniforms:{mouseSize:(e,n)=>{let{mouseSize:t}=n;return"number"==typeof t?1/t*25:25},mouseSizeFactor:(e,n)=>{let{mouseSize:t}=n;return"number"==typeof t?t:1},fluidSpreadVelocity:(e,n)=>{let{fluidSpreadVelocity:t}=n;return"number"==typeof t?t:1},texture:e.prop("texture"),shapeTexture:e.prop("shapeTexture"),aspect:e=>{let{viewportWidth:n,viewportHeight:t}=e;return n/t},delta:e.prop("delta"),normalizedDelta:e.prop("normalizedDelta"),mouse:e.prop("mouse"),pixelRatio:e.context("pixelRatio"),dSize:(e,n)=>{let{textureSize:t}=n;return[1/t[0],1/t[1]]},shapeTextureDSize:(e,n)=>{let{shapeTextureSize:t}=n;return[1/t[0],1/t[1]]},uTime:e.context("time"),mouseSpeed:e.prop("mouseSpeed")}})},62062:(e,n,t)=>{"use strict";t.d(n,{i:()=>a});var i=t(71471),o=t(48961),r=t(4748);function a(e){let{text:n,disabled:t}=e,a=(0,r.Ny)(),{ref:l,replay:u}=(0,o.x)({text:n,speed:.6,step:Math.max(Math.floor(.18*n.length),1),scramble:1,playOnMount:!1});return(0,i.jsx)("span",{onPointerEnter:()=>!t&&!a&&u(),ref:l,children:n})}},86038:(e,n,t)=>{"use strict";t.d(n,{t:()=>r});var i=t(96995);let o=(e,n,t)=>e.buffer(Array.from({length:n*t},(e,i)=>{let o=i%n/(n-1),r=Math.floor(i/n)/(t-1);return[o=2*o-1,r=2*r-1]})),r=(e,n,t)=>e({vert:"\n      precision highp float;\n\n      attribute vec2 position;\n\n      uniform float uPointSize;\n      uniform vec2 uResolution;\n      uniform sampler2D uShapeTexture;\n      uniform sampler2D uDisplacementTexture;\n      uniform sampler2D uNoiseTexture;\n      uniform float uTime;\n      uniform float uDisplacementScale;\n      uniform float uLeft;\n      uniform float uTop;\n      uniform float uWidth;\n      uniform float uHeight;\n\n      varying vec2 pointUvCenter;\n      varying vec2 pointUvSize;\n      varying float timedNoise;\n      varying float staticNoise;\n      varying float displacementMagnitude;\n      varying float displacementZ;\n      varying float zPos;\n\n      float valueRemap(float value, float min, float max, float newMin, float newMax) {\n        return (value - min) / (max - min) * (newMax - newMin) + newMin;\n      }\n\n      float round(float value, float step) {\n        return floor(value / step + 0.5) * step;\n      }\n\n      float round(float value) {\n        return round(value, 1.0);\n      }\n\n      ".concat(i.B,"\n\n      void main() {\n\n        float aspect = uResolution.x / uResolution.y;\n        vec2 toAspect = vec2(aspect, 1.);\n        float pointSize = uPointSize;\n        vec2 pointPosition = position;\n\n        pointPosition.x = valueRemap(pointPosition.x, -1., 1., uLeft, uLeft + uWidth);\n        pointPosition.x = valueRemap(pointPosition.x, 0., uResolution.x, -1., 1.);\n        pointPosition.y = valueRemap(pointPosition.y, 1., -1., uTop, uTop + uHeight);\n        pointPosition.y = valueRemap(pointPosition.y, 0., uResolution.y, 1., -1.);\n\n        pointUvCenter = (pointPosition + 1.0) * 0.5;\n\n        vec4 sampleAtCenter = texture2D(uShapeTexture, pointUvCenter);\n\n        // calculate noise\n        timedNoise = cnoise(pointPosition * toAspect * 100.0 + uTime * 0.2);\n        staticNoise = cnoise(pointPosition * uResolution * 0.03);\n\n        // sample flowMap: xy = direction, z = magnitude\n        vec3 displacementSmaple = texture2D(uDisplacementTexture, pointUvCenter).xyz;\n        displacementZ = pow(displacementSmaple.z * uDisplacementScale, 2.);\n        // use green value of texture to scale displacement\n        displacementZ *= sampleAtCenter.g;\n        vec2 displacementDirection = displacementSmaple.xy - vec2(0.5);\n        displacementDirection.y *= aspect;\n\n        // magnitude of displacement\n        displacementMagnitude = displacementZ * 0.23;\n        displacementMagnitude *= valueRemap(timedNoise, -1., 1., -0.5, 1.);\n\n        // calculate displacement\n        vec2 displacement = displacementDirection * displacementMagnitude;\n\n        // round displacement to give a pixelated effect\n        vec2 roundedDisplacement = floor(displacement * (uResolution/(uPointSize * 2.))) / (uResolution/(uPointSize * 2.));\n        // mix rounded and original based on displacementMagnitude\n        displacement = mix(displacement, roundedDisplacement, min(abs(displacementMagnitude) * 10., 1.));\n\n        // add displacement to point position\n        pointPosition += displacement;\n\n        // calculate pointUvSize using uResolution\n        pointUvSize = uPointSize / uResolution;\n        gl_PointSize = pointSize;\n\n        // offset zPos to avoid particles clipping\n        zPos = sampleAtCenter.r < 0.3 ? 0.99 : staticNoise * 0.5;\n        gl_Position = vec4(pointPosition, zPos, 1);\n      }"),frag:"\n      precision highp float;\n\n      uniform float uPointSize;\n      uniform sampler2D uShapeTexture;\n      uniform float uDisplacementScale;\n      uniform float uParticleSizeScale;\n      uniform float uLeft;\n      uniform float uTop;\n      uniform float uWidth;\n      uniform float uHeight;\n      uniform vec2 uResolution;\n\n      varying vec2 pointUvCenter;\n      varying vec2 pointUvSize;\n      varying float timedNoise;\n      varying float staticNoise;\n      varying float displacementMagnitude;\n      varying float displacementZ;\n      varying float zPos;\n\n      void main() {\n        // color rsult\n        vec3 fragColor = vec3(0.0);\n        float fragAlpha = 1.0;\n\n        bool isDisplaced = abs(displacementZ) > 0.1;\n\n        vec2 pointUv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n        // remaped coord point into the base uv\n        vec2 pointMapUv = pointUvCenter + (pointUv - vec2(0.5, 0.5)) * pointUvSize;\n\n        float distFromCenter = distance(pointUv, vec2(0.5, 0.5));\n\n        vec3 textureSample = texture2D(uShapeTexture, pointMapUv).rgb;\n        float sampleAtCenter = texture2D(uShapeTexture, pointUvCenter).r;\n\n        float pointAlpha = step(distFromCenter, 0.35 * uParticleSizeScale);\n\n        fragColor = isDisplaced ? vec3(sampleAtCenter) : vec3(textureSample.r);\n        fragAlpha = isDisplaced ? pointAlpha : textureSample.r;\n\n        // the higher value more particles\n        float displacementBarrier = 0.8;\n\n        float displacementMask = (displacementZ / uDisplacementScale) * 2. - displacementBarrier * 2.;\n        if(staticNoise < displacementMask) discard;\n        if(isDisplaced && pointAlpha == 0.) discard;\n\n        gl_FragColor = vec4(fragColor, fragAlpha);\n      }\n    ",attributes:{position:o(e,n,t)},uniforms:{uPixelRatio:e.context("pixelRatio"),uLeft:(e,n)=>{let{left:t}=n;return"number"==typeof t?t:0},uTop:(e,n)=>{let{top:t}=n;return"number"==typeof t?t:0},uWidth:(e,n)=>{let{viewportWidth:t}=e,{width:i}=n;return"number"==typeof i?i:t},uHeight:(e,n)=>{let{viewportHeight:t}=e,{height:i}=n;return"number"==typeof i?i:t},uParticleSizeScale:(e,n)=>{let{particleSizeScale:t=1}=n;return t},uDisplacementScale:(e,n)=>{let{displacementScale:t=1}=n;return t},uShapeTexture:e.prop("shapeTexture"),uDisplacementTexture:e.prop("displacementTexture"),uMouseUv:e.prop("mouseUv"),uPointSize:(e,i)=>{let{viewportWidth:o,viewportHeight:r}=e,{textureSize:a,particleSize:l}=i;if("number"==typeof l)return l;let u=a||[o,r];return 1.2*Math.max(u[0]/n,u[1]/t)},uResolution:(e,n)=>{let{viewportWidth:t,viewportHeight:i}=e,{textureSize:o}=n;return o||[t,i]},uTime:e.context("time")},count:n*t,primitive:"points"})},96995:(e,n,t)=>{"use strict";t.d(n,{B:()=>i});let i='\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n'}}]);